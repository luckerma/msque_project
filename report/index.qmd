---
title: "Wireless Network Modeling and Simulation"
subtitle: "UGE: M2 SIA - Project Report"
authors:
  - name: "Luca Uckermann"
    affiliation:
      - id: THK
        name: "University of Applied Sciences (TH Köln)"
        city: "Cologne"
        country: "Germany"
    corresponding: true
    orcid: "0009-0005-2957-6331"
bibliography: references.bib
date: last-modified
number-sections: true
link-citations: true
execute: 
  eval: true
  echo: true
  output: true
  warning: false
  error: false
  include: true

abstract: |
  Abstract
---

# Introduction

INET wireless tutorial [@inet_wireless_tutorial2024].

op_env [@op_env2024].

# Configuration

## Step 1

### Simulate and measure the transmission rate.

After each transmitted packet, the following output is generated:

```plaintext
UDPData-1 (8.504 ms 1063 B)
```

The output shows that the packet `UDPData-1` was transmitted after `8.504 ms` with a size of `1063 bytes`.

### Is the inter-arrival time for the packets memoryless? Explain your answer.

One line of the 'omnetpp.ini' configuration file is as follows:

```plaintext
*.hostA.app[0].sendInterval = exponential(12ms)
```

From the configuration, it is clear that the inter-arrival times are memoryless because the `sendInterval` is explicitly defined as `exponential(12ms)`. This is a key property of exponential distributions, which are memoryless.

Another approach is to analyze the output of the simulation:

```plaintext
Event #17
Reception ended: successfully (8.504 ms 1063 B)

Event #6122
Reception ended: successfully (8.504 ms 1063 B)
```

Even after a lot of events the arrival time of the packets is still constant at `8.504 ms`, which is a characteristic of memoryless processes.

### Compute the total number of packets transmitted during the simulation time. Explain why the transmission rate was around 660 kbps.

The simulation stops after `20` seconds with the following output:

```plaintext
Simulation time limit reached -- at t=20s, event #20746
Transmission count = 1596
```

A total of `1596` packets were transmitted during the simulation time.

```plaintext
totalLengthField = 1028
```

The total length of one packet is `1028` bytes.

The transmission rate is calculated as follows:

$$
\begin{aligned}
\text{Transmission Rate} &= \frac{\text{totalLengthField} \times \text{Transmission count}}{\text{Simulation time}} \\
&= \frac{1028 \text{bytes} \times 1596}{20 \text{s}} = 82034.4 \text{bytes/s} \\
&= 82034.4 \text{bytes/s} \times 8 \text{bits/byte} = 656275.2 \text{bits/s} \\
&= 656.2752 \text{kbps}
\end{aligned}
$$ {#eq-transmission_rate}

@eq-transmission_rate shows that the transmission rate is around `656 kbps`, which is close to the expected value of `660 kbps`.

### Reproduce the simulation and confirm that the results remain consistent.

All simulation runs come to the same result:

```plaintext
Simulation time limit reached -- at t=20s, event #20746

Transmission count = 1596
Signal send count = 1596
Reception computation count = 1596
```

The transmission count is always `1596` packets, which confirms the consistency of the results. The event number is also the same in all runs, which indicates that the simulation is deterministic.

### Modify the random number generator seed in `omnetpp.ini`. How does changing the seed impact the simulation results?

To modify the random number generator seed, the following line in the `omnetpp.ini` file is changed:

```plaintext
seed-set = 1337
```

After changing the seed, the simulation is run again. The results are as follows:

```plaintext
Simulation time limit reached -- at t=20s, event #21022

Transmission count = 1617
Signal send count = 1617
Reception computation count = 1617
```

The transmission count is now `1617` packets, which is different from the previous result. This shows that changing the seed impacts the simulation results. In this case, the number of transmitted packets increased by `21`.

### List all parameters of the MAC protocol used in `AckingWirelessInterface` with references to the source code.

The parameters in the `omnetpp.ini` file are as follows:

```plaintext
*.host*.wlan[0].typename = "AckingWirelessInterface"
*.host*.wlan[0].mac.useAck = false
*.host*.wlan[0].mac.fullDuplex = false
*.host*.wlan[0].radio.transmitter.communicationRange = 500m
*.host*.wlan[0].radio.receiver.ignoreInterference = true
*.host*.wlan[0].mac.headerLength = 23B
```

and in the `inet-4.5.4/src/inet/linklayer/acking/AckingWirelessInterface.ned` file (l. 30-36):

```plaintext
parameters:
        string interfaceTableModule;
        string energySourceModule = default("");
        double bitrate @unit(bps);
        *.interfaceTableModule = default(absPath(this.interfaceTableModule));
        *.energySourceModule = default(absPath(this.energySourceModule));
        **.bitrate = this.bitrate;
```

### Explain the `throughput:vector` statistic in the analysis file by citing its definition and implementation in the source code.

Information can be found in `/inet-4.5.4/src/inet/applications/udpapp/UdpBasicApp.ned` (l. 55-57):

```plaintext
@signal[packetReceived](type=inet::Packet);
@statistic[packetReceived](title="packets received"; source=packetReceived; record=count,"sum(packetBytes)","vector(packetBytes)"; interpolationmode=none);
@statistic[throughput](title="throughput"; unit=bps; source="throughput(packetReceived)"; record=vector);
```

The `packetReceived` signal, of type `inet::Packet`, is emitted whenever a packet is received by the module, serving as the foundation for related metrics. The `packetReceived` statistic uses this signal to record three key metrics: the total number of packets received (`count`), the cumulative size of received packets (`sum(packetBytes)`), and the individual sizes of packets as a time-series vector (`vector(packetBytes)`), with no interpolation applied to the discrete events. The `throughput` statistic, also derived from the `packetReceived` signal, calculates and records the throughput (rate of data received) in bits per second (`bps`) as a time-series vector. This setup allows for detailed tracking and analysis of packet reception and throughput performance over time during the simulation.

The analysis file (`Wireless.vec`) contains the following lines related to the `throughput:vector` statistic:

```plaintext
vector 82 WirelessA.hostB.app[0] throughput:vector ETV
attr source throughput(packetReceived)
attr title throughput
```

These lines show that the `throughput:vector` statistic is associated with the `packetReceived` signal from the `hostB` application module, providing insights into the throughput performance of the network.

## Step 2

### Visualize the radio transmission range.

### Change the communication range so that host B is no longer reachable from host A. Visualize the new range.

### Provide simulation results for the transmission rate and explain them.

## Step 3

### Identify the type of wireless interfaces for the new hosts. Explain your answer with references to the source code.

## Step 4

### Use the runtime GUI to capture a screenshot showing the IP addresses of all hosts in the network.

## Step 5 {#sec-step_5}

### Enable event log recording in the runtime GUI.

### Open the `.elog` ﬁle with a text editor and explain its contents.

### Analyze the event log using the sequence chart and event log table tools. Filter events for `hostA+udp`, `hostB+udp`, and `hostR1+ip`.

### Take screenshots and comment on both a complete and an incomplete transmission sequence chart.

## Step 6 {#sec-step_6}

### 1. Compare the number of packets received by host B in this configuration with the results from `Configuration Step 5` (@sec-step_5). Explain the difference.

## Step 7 {#sec-step_7}

### Measure the `numRetry` statistic for `Configuration Steps 6` (@sec-step_6) and `7` (@sec-step_7).

### Cite the source code where the logic for `numRetry` is defined.

### Explain the differences in this metric between the two configurations.

## Step 9

### Plot the throughput vector at host B and identify the time when the transmission stops.

# Conclusion

# References

::: {#refs}
:::